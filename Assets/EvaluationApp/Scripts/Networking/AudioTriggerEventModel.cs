using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Normal.Realtime;
using Normal.Realtime.Serialization;

[RealtimeModel]
public partial class AudioTriggerEventModel
{
    [RealtimeProperty(1, true)] private int _trigger;
    [RealtimeProperty(2, true)] private int _senderID;


}

/* ----- Begin Normal Autogenerated Code ----- */
public partial class AudioTriggerEventModel : RealtimeModel
{
    public int trigger
    {
        get
        {
            return _triggerProperty.value;
        }
        set
        {
            if (_triggerProperty.value == value) return;
            _triggerProperty.value = value;
            InvalidateReliableLength();
        }
    }

    public int senderID
    {
        get
        {
            return _senderIDProperty.value;
        }
        set
        {
            if (_senderIDProperty.value == value) return;
            _senderIDProperty.value = value;
            InvalidateReliableLength();
        }
    }

    public enum PropertyID : uint
    {
        Trigger = 1,
        SenderID = 2,
    }

    #region Properties

    private ReliableProperty<int> _triggerProperty;

    private ReliableProperty<int> _senderIDProperty;

    #endregion

    public AudioTriggerEventModel() : base(null)
    {
        _triggerProperty = new ReliableProperty<int>(1, _trigger);
        _senderIDProperty = new ReliableProperty<int>(2, _senderID);

        SubscribeEventCallback(Normal.Realtime.RealtimeModelEvent.OnDidRead, DidRead);
    }

    protected override void OnParentReplaced(RealtimeModel previousParent, RealtimeModel currentParent)
    {
        _triggerProperty.UnsubscribeCallback();
        _senderIDProperty.UnsubscribeCallback();
    }

    protected override int WriteLength(StreamContext context)
    {
        var length = 0;
        length += _triggerProperty.WriteLength(context);
        length += _senderIDProperty.WriteLength(context);
        return length;
    }

    protected override void Write(WriteStream stream, StreamContext context)
    {
        var writes = false;
        writes |= _triggerProperty.Write(stream, context);
        writes |= _senderIDProperty.Write(stream, context);
        if (writes) InvalidateContextLength(context);
    }

    protected override void Read(ReadStream stream, StreamContext context)
    {
        var anyPropertiesChanged = false;
        while (stream.ReadNextPropertyID(out uint propertyID))
        {
            var changed = false;
            switch (propertyID)
            {
                case (uint)PropertyID.Trigger:
                    {
                        changed = _triggerProperty.Read(stream, context);
                        break;
                    }
                case (uint)PropertyID.SenderID:
                    {
                        changed = _senderIDProperty.Read(stream, context);
                        break;
                    }
                default:
                    {
                        stream.SkipProperty();
                        break;
                    }
            }
            anyPropertiesChanged |= changed;
        }
        if (anyPropertiesChanged)
        {
            UpdateBackingFields();
        }
    }

    private void UpdateBackingFields()
    {
        _trigger = trigger;
        _senderID = senderID;
    }
    public void FireEvent(int senderID)
    {
        this.trigger++;
        this.senderID = senderID;
        //eventDidFire(senderID);
    }

    // An event that consumers of this model can subscribe to in order to respond to the event
    public delegate void EventHandler(int senderID);
    public event EventHandler eventDidFire1;

    // A RealtimeCallback method that fires whenever we read any values from the server
    [RealtimeCallback(RealtimeModelEvent.OnDidRead)]
    private void DidRead()
    {
        if (eventDidFire1 != null && trigger == 1)
        {
            eventDidFire1(senderID);
            trigger = 0;
        }
    }
}
/* ----- End Normal Autogenerated Code ----- */
